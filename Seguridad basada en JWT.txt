Seguridad basada en JWT (JSON Web Token)
 Muy utilizada en APIs REST
JWT es un estándar abierto (RFC 7519) ampliamente adoptado para autenticación sin estado en APIs REST. Permite que cada petición incluya un token autocontenido con la identidad y permisos del usuario, evitando la necesidad de mantener sesiones en el servidor.
Integración de Spring Security con JWT
Spring Security puede extenderse fácilmente para trabajar con JWT mediante filtros personalizados que interceptan las solicitudes HTTP:
1.	JWTAuthenticationFilter:
o	Se activa en el endpoint de login.
o	Valida las credenciales del usuario.
o	Genera y firma un JWT (usando, por ejemplo, io.jsonwebtoken.Jwts).
o	Devuelve el token al cliente en la respuesta.
2.	JWTAuthorizationFilter:
o	Se ejecuta en cada petición posterior.
o	Extrae el token del header Authorization: Bearer <token>.
o	Verifica la firma y la validez (exp, iss, etc.).
o	Si es válido, carga los detalles del usuario (UserDetails) y establece el contexto de seguridad (SecurityContextHolder).
Ejemplo básico de implementación
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    private final String SECRET = "ClaveSecretaMuySegura";
    private final long EXPIRATION_TIME = 864_000_000; // 10 días

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable()
            .authorizeRequests()
                .antMatchers("/auth/login").permitAll()
                .anyRequest().authenticated()
            .and()
            .addFilter(new JWTAuthenticationFilter(authenticationManager()))
            .addFilter(new JWTAuthorizationFilter(authenticationManager()));
    }

    // Configuración de autenticación en memoria para el ejemplo
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
            .withUser("user")
            .password("{noop}password")
            .roles("USER");
    }

    // Filtro para autenticar y generar el JWT
    public class JWTAuthenticationFilter extends UsernamePasswordAuthenticationFilter {
        public JWTAuthenticationFilter(AuthenticationManager authManager) {
            setAuthenticationManager(authManager);
            setFilterProcessesUrl("/auth/login");
        }

        @Override
        public Authentication attemptAuthentication(HttpServletRequest req,
                                                    HttpServletResponse res) {
            try {
                User creds = new ObjectMapper()
                    .readValue(req.getInputStream(), User.class);
                return getAuthenticationManager().authenticate(
                    new UsernamePasswordAuthenticationToken(
                        creds.getUsername(),
                        creds.getPassword(),
                        new ArrayList<>()
                    )
                );
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

        @Override
        protected void successfulAuthentication(HttpServletRequest req,
                                                HttpServletResponse res,
                                                FilterChain chain,
                                                Authentication auth) {
            String token = Jwts.builder()
                .setSubject(((User) auth.getPrincipal()).getUsername())
                .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TIME))
                .signWith(SignatureAlgorithm.HS512, SECRET.getBytes())
                .compact();
            res.addHeader("Authorization", "Bearer " + token);
        }
    }

    // Filtro para validar el JWT en cada petición
    public class JWTAuthorizationFilter extends BasicAuthenticationFilter {
        public JWTAuthorizationFilter(AuthenticationManager authManager) {
            super(authManager);
        }

        @Override
        protected void doFilterInternal(HttpServletRequest req,
                                        HttpServletResponse res,
                                        FilterChain chain) throws IOException, ServletException {
            String header = req.getHeader("Authorization");
            if (header == null || !header.startsWith("Bearer ")) {
                chain.doFilter(req, res);
                return;
            }
            UsernamePasswordAuthenticationToken authentication = getAuthentication(req);
            SecurityContextHolder.getContext().setAuthentication(authentication);
            chain.doFilter(req, res);
        }

        private UsernamePasswordAuthenticationToken getAuthentication(HttpServletRequest req) {
            String token = req.getHeader("Authorization");
            if (token != null) {
                // parse the token.
                String user = Jwts.parser()
                    .setSigningKey(SECRET.getBytes())
                    .parseClaimsJws(token.replace("Bearer ", ""))
                    .getBody()
                    .getSubject();
                if (user != null) {
                    return new UsernamePasswordAuthenticationToken(user, null, new ArrayList<>());
                }
                return null;
            }
            return null;
        }
    }
}





Cómo funciona:
1.	El cliente hace POST /auth/login con JSON { "username": "...", "password": "..." }.
2.	JWTAuthenticationFilter autentica y añade el header Authorization: Bearer <token>.
3.	En cada llamada subsecuente, JWTAuthorizationFilter valida el token y establece el usuario en el contexto de seguridad.
Spring. (2024). OAuth 2.0 Resource Server JWT. Retrieved April 5, 2025, from https://docs.spring.io/spring-security/reference/servlet/oauth2/resource-server/jwt.html

